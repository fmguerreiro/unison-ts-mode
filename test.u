-- Complex Unison test file exercising many language features

{{
A documentation literal with {List.map} term link,
{type Optional} type link, and @signature{List.foldLeft}.
}}

use base List Nat Text Optional
use base.List map foldLeft

-- Structural type with multiple constructors
structural type Result a e
  = Ok a
  | Err e

-- Unique type (enum-like)
unique type Priority = Low | Medium | High | Critical

-- Record type
type Task = {
  id : Nat,
  title : Text,
  priority : Priority,
  completed : Boolean
}

-- Ability declaration
structural ability State s where
  get : {State s} s
  put : s ->{State s} ()
  modify : (s -> s) ->{State s} ()

structural ability Throw e where
  throw : e ->{Throw e} a

-- Type signature with abilities
runState : s -> '{State s} a -> (a, s)
runState initial thunk =
  handler : s -> Request (State s) a -> (a, s)
  handler state = cases
    {State.get -> resume}      -> handler state (resume state)
    {State.put new -> resume}  -> handler new (resume ())
    {State.modify f -> resume} -> handler (f state) (resume ())
    {pure}                     -> (pure, state)
  handle !thunk with handler initial

-- Polymorphic function with forall
identity : forall a. a -> a
identity x = x

-- Complex pattern matching
describePriority : Priority -> Text
describePriority = cases
  Low      -> "low priority"
  Medium   -> "medium priority"
  High     -> "high priority"
  Critical -> "CRITICAL!"

-- List patterns
processItems : [a] -> Nat
processItems = cases
  []           -> 0
  [single]     -> 1
  [a, b]       -> 2
  h +: t       -> 1 + processItems t

-- Snoc and concat patterns
lastTwo : [a] -> Optional (a, a)
lastTwo = cases
  _ ++ [x, y] -> Some (x, y)
  _           -> None

-- Guards and as-patterns
categorize : Nat -> Text
categorize = cases
  n@0          -> "zero: " ++ Nat.toText n
  n | n < 10   -> "small: " ++ Nat.toText n
  n | n < 100  -> "medium: " ++ Nat.toText n
  n            -> "large: " ++ Nat.toText n

-- Nested destructuring with tuples
swap : (a, b) -> (b, a)
swap = cases (x, y) -> (y, x)

-- Lambda variations
examples : [Nat]
examples =
  let
    list = [1, 2, 3, 4, 5]
    doubled = map (x -> x * 2) list
    incremented = map (Nat.increment) list
    filtered = List.filter (n -> n > 2) list
    summed = foldLeft (acc x -> acc + x) 0 list
    _ = summed  -- ignore binding
    doubled

-- Delayed computation / thunks
lazyValue : 'Text
lazyValue = do
  "This is computed lazily"

forceIt : Text
forceIt = !lazyValue

-- Operators
(+++) : Text -> Text -> Text
a +++ b = a ++ " " ++ b

infixExample : Text
infixExample = "Hello" +++ "World"

-- Ability handler with multiple abilities
safeDiv : Nat -> Nat ->{Throw Text} Nat
safeDiv x y =
  if y == 0 then Throw.throw "Division by zero"
  else x / y

catchThrow : '{Throw e} a -> Result a e
catchThrow computation =
  handle !computation with cases
    {Throw.throw e -> _} -> Err e
    {pure}               -> Ok pure

-- Record operations
createTask : Nat -> Text -> Task
createTask id title = Task id title Medium false

completeTask : Task -> Task
completeTask task =
  Task.completed.set true task
    |> Task.priority.set High

-- Complex expression with multiple let bindings
complexCalculation : Nat -> Nat
complexCalculation input =
  let
    step1 = input * 2
    step2 = step1 + 10
    step3 =
      if step2 > 100 then step2 / 2
      else step2 * 3
    use Nat + - *
    result = step3 + step1 - input
    result

-- Hash reference example (commented - would need real hash)
-- referenced = #abc123

-- Bytes literal
someBytes : Bytes
someBytes = 0xsdeadbeef

-- Char literals
chars : [Char]
chars = [?a, ?Z, ?=%, ?\n, ?\t]

-- Multiline text
multiline : Text
multiline = """
  This is a multiline
  text literal that
  spans multiple lines.
"""

-- Numeric literals
numbers : (Nat, Int, Float)
numbers = (42, +100, -3.14159)

-- Hex nat
hexValue : Nat
hexValue = 0xFF
